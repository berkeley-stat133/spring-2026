---
title: "Functions"
format: stat133slides-revealjs
revealjs-plugins:
  - drop
chalkboard: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, error = TRUE)
```


## While you're waiting ...

__Question__: What will the following code return?

```{r eval = FALSE}
expr <- {
  x <- 1
  y <- 2
  z <- c(x, y)
}

expr
```


## While you're waiting ...

__Question__: What will the following code return?

```{r eval = FALSE}
a <- 10
b <- 20

hey <- function() {
  a <- 1
  b <- 2
  c(a, b)
}

hey()
```


# Defining a Function

## Ex. `colSums()`

. . .

```{r}
#| output-location: fragment
mat <- matrix(1:4, nrow = 2)
mat
```

. . .

```{r}
#| output-location: fragment
colSums(mat)
```

. . .

How could I compute this without `colSums()`?

. . .

```{r}
#| output-location: fragment
c(sum(mat[, 1]), sum(mat[, 2]))
```


##

I could generalize with a for-loop

. . .

```{r}
#| code-line-numbers: "1|1-3|1-5|1-7"
#| output-location: fragment
colsum_vec <- rep(0, ncol(mat))

for (coln in 1:ncol(mat)) {
  colsum_vec[coln] <- sum(mat[, coln])
}

colsum_vec
```


## Why use `colSums()` instead?

1) Make your code more readable
2) Don't Repeat Yourself (DRY)
3) Focus on the variables, not the constants
4) Easier to test, update


## Building a function

. . . 

```{r}
# celsius to fahrenheit
c2f <- function(celsius) {
  (9/5) * celsius + 32
}
```

- Create a new function with `function()`
- Define the function name, arguments, and expression
- Creates a new object, `c2f()` in your environment
- Last line will be returned (or use `return()`)


## Scoping

__Question__: What will the following code return?

```{r}
#| output-location: fragment
a <- 10
b <- 20

hey <- function() {
  a <- 1
  b <- 2
  c(a, b)
}

hey()
```


##

```{r}
#| output-location: fragment
a <- 2

yay <- function() {
  b <- 1
  c(a, b)
}

yay()
```

- The environment within the function includes the environment "one level up"
- Objects defined in the function environment mask those one level up
- Best to _encapsulate_ functions (not make them dependent on objects defined outside their environment / arguments)


# Building a Die Roller

## Example 1: Roll a Die {auto-animate=true}

Task: return a numeric vector with the result of rolling a fair six-sided die.

```{r eval = FALSE}
  sample(x = 1:6, size = 1)
```


## Example 1: Roll a Die {auto-animate=true}

Task: return a numeric vector with the result of rolling a fair six-sided die.

```{r}
roll_die <- function() {
  sample(x = 1:6, size = 1)
}
```

. . .

__Question__: Modify this function so it can

::: {.fragment .highlight-red}
work for arbitrary n-sided dice
:::

return more than 1 roll of the die

```{r}
#| echo: false
countdown::countdown(2, bottom = 0)
```


## Example 1: Roll a Die {auto-animate=true}

Task: return a numeric vector with the result of rolling a fair six-sided die.

```{r}
roll_die <- function(n_sides = 6) {
  sample(x = 1:n_sides, size = 1)
}
```

__Question__: Modify this function so it can

work for arbitrary n-sided dice

::: {.fragment .highlight-red}
return more than 1 roll of the die
:::


## Example 1: Roll a Die {auto-animate=true}

Task: return a numeric vector with the result of rolling a fair six-sided die.

```{r}
roll_die <- function(n_sides = 6, n_rolls = 1) {
  sample(x = 1:n_sides, size = n_rolls, replace = TRUE)
}
```

__Question__: Modify this function so it can

work for arbitrary n-sided dice

return more than 1 roll of the die


## Why write functions?

1) Make your code more readable

2) Don't Repeat Yourself (DRY)

3) Focus on the variables, not the constants

4) Easier to test, update


# `stop()` and `warning()`

## Error Messages with `stop()`

```{r}
roll_die <- function(n_sides = 6, n_rolls = 1) {
  if (n_sides <= 0) {
    stop("invalid value n_sides")
  }
  sample(x = 1:n_sides, size = n_rolls, replace = TRUE)
}
```

. . .

\

```{r}
#| output-location: fragment
roll_die(n_sides = -3, n_rolls = 2)
```


## Error Messages with `stop()`

```{r}
roll_die <- function(n_sides = 6, n_rolls = 1) {
  if (n_sides <= 0) {
    stop("invalid value n_sides")
  }
  if (n_rolls <= 0) {
    stop("invalid value n_rolls")
  }
  sample(x = 1:n_sides, size = n_rolls, replace = TRUE)
}
```

. . .

\

```{r}
#| output-location: fragment
roll_die(n_sides = 3, n_rolls = 0)
```


## Warning Messages with `warning()`

```{r}
roll_die <- function(n_sides = 6, n_rolls = 1) {
  if (n_sides <= 0) {
    warning("invalid n_sides, default n_sides = 6")
    n_sides = 6
  }
  sample(x = 1:n_sides, size = n_rolls, replace = TRUE)
}
```

. . .

\

```{r}
#| output-location: fragment
#| warning: true
roll_die(n_sides = -3, n_rolls = 2)
```


