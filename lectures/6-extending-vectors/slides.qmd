---
title: "Extending Vectors"
subtitle: "2-dimensional atomic objects"
format: stat133slides-revealjs
revealjs-plugins:
  - drop
chalkboard: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, error = TRUE)
```

## Review

## Change in place syntax

You can assign into a subsetted vector to change its contents in place.

```{r}
#| output-location: fragment
z <- c(latte = 2, boba = 4, matcha = 6)
z[c(TRUE, FALSE, TRUE)] <- 12
z
```

. . .

```{r}
#| output-location: fragment
names(z)
```

. . .

```{r}
#| output-location: fragment
names(z) <- c("A", "B", "C")
z
```


## Question

```{r}
w <- c(FALSE, FALSE, TRUE, TRUE, FALSE)
```

Write down two ways to change-in-place the `FALSE` to `TRUE`, each using a different form of subsetting.

```{r}
#| echo: false
countdown::countdown(1.5, bottom = 0)
```


## Review Vectors

- Central data structure in R
- Vectorization
- Vector Recycling
- Ordered set of elements
- Subsetting with `[]`
- Atomic: elements of the same type
- Coercion


# Matrices

## Matrix

A two-dimensional data structure for atomic data. Created with `matrix()`.

```{r}
#| output-location: fragment
mat1 <- matrix(data = c(1, 2, 3, 4), nrow = 2, ncol = 2)
mat1
```

. . .

```{r}
#| output-location: fragment
typeof(mat1)
```

. . .

Note: defaults to fill the matrix by columns (`byrow = FALSE`)


## Creating matrices with `matrix()`

```{r}
#| output-location: fragment
mat1 <- matrix(data = c(1, 2, 3, 4), nrow = 2, ncol = 2)
mat1
```

. . .

```{r}
#| output-location: fragment
mat2 <- matrix(data = c(1, 2, 3, 4), nrow = 2)
mat2
```

. . .

```{r}
#| output-location: fragment
mat3 <- matrix(data = c(1, 2, 3, 4), ncol = 2)
mat3
```


## Creating matrices with `matrix()`

To fill the matrix by rows use `byrow = TRUE`

```{r}
#| output-location: fragment
mat4 <- matrix(data = c(1, 2, 3, 4), nrow = 2, byrow = TRUE)
mat4
```

. . .

```{r}
#| output-location: fragment
mat5 <- matrix(data = c(1, 2, 3, 4), ncol = 2, byrow = TRUE)
mat5
```


## Matrices as Vectors

```{r}
#| output-location: fragment
vec <- 1:4
vec
```

\

. . .

```{r}
#| output-location: fragment
dim(vec) <- c(2, 2)
vec
```

. . .

Matrices are simply vectors with dimensions `dim()`. All vector behavior still applies.


## Question

Using what you know about how vectors work, predict the outcome of the following:

```{r}
#| eval: false
matrix(c(1, 2, 3, 4), nrow = 2) *
    matrix(c(1, 2, 3, 4), nrow = 2)
```

\

```{r}
#| eval: false
matrix(data = c("iz", "buzz", "poppy"), nrow = 2)
```

\

```{r}
#| eval: false
matrix(c(TRUE, 3L, 1.0, FALSE), nrow = 2)
```

```{r}
#| echo: false
countdown::countdown(2, bottom = 0)
```


# Matrix Subsetting

## Subsetting vectors vs matrices


## By Index

```{r}
#| output-location: fragment
mat <- matrix(1:4, nrow = 2)
mat
```

. . .

```{r}
#| output-location: fragment
mat[1, 2]
```


## By Index (cont'd)

```{r}
mat2 <- matrix(1:9, nrow = 3)
mat2
```

. . .

```{r}
#| output-location: fragment
mat2[1:2, 2:3]
```


## By Index (cont'd)

```{r}
mat2 <- matrix(1:9, nrow = 3)
mat2
```

. . .

```{r}
#| output-location: fragment
mat2[1, ]
```
 
. . . 

Notes:

- subsetting a matrix row creates a vector
- empty subsetting vectors > all entries


## By Name

```{r}
#| output-location: fragment
mat <- matrix(1:4, nrow = 2)
rownames(mat) <- c("a", "b")
colnames(mat) <- c("i", "ii")
mat
```

. . .

```{r}
#| output-location: fragment
mat["a", "ii"]
```

. . .

```{r}
#| output-location: fragment
mat["a", ]
```

. . .

```{r}
#| output-location: fragment
mat[ ,"ii"]
```


## By Logical


```{r}
#| output-location: fragment
mat[c(TRUE, FALSE), c(FALSE, TRUE)]
```

. . .

\

### You can mix and match

```{r}
#| output-location: fragment
mat["a", c(FALSE, TRUE)]
```


## What's going on here?

```{r}
#| output-location: fragment
mat
```

. . .

```{r echo = 2}
#| output-location: fragment
mat_log <- matrix(c(TRUE, FALSE, TRUE, FALSE), 2, 2)
mat_log
```

. . .

### Question

What will the following command produce? Why?

```{r}
#| eval: false
mat[mat_log]
```

```{r}
#| echo: false
countdown::countdown(1, bottom = 0)
```


# Matrices and Tables

##

| [Name]{.bold-hilit} | [Height]{.bold-hilit} | [Force]{.bold-hilit} |
|------|------------|:------:|
| Leia | 1.50 | TRUE |
| Luke | 1.70 | TRUE |
| Han  | 1.80 | FALSE |

. . .

Write code to create a 3x3 matrix for the above data.

```{r}
#| echo: false
countdown::countdown(1.5, bottom = 0)
```

. . .

```{r}
Name <- c("Leia", "Luke", "Han")
Height <- c(1.50, 1.70, 1.80)
Force <- c(TRUE, TRUE, FALSE)

M1 <- matrix(c(Name, Height, Force), nrow = 3)
M1
```


##

| [Name]{.bold-hilit} | [Height]{.bold-hilit} | [Force]{.bold-hilit} |
|------|------------|:------:|
| Leia | 1.50 | TRUE |
| Luke | 1.70 | TRUE |
| Han  | 1.80 | FALSE |

Write code to create a 3x3 matrix for the above data.

```{r}
#| output-location: fragment
Name <- c("Leia", "Luke", "Han")
Height <- c(1.50, 1.70, 1.80)
Force <- c(TRUE, TRUE, FALSE)

M1 <- matrix(c(Name, Height, Force), nrow = 3)
colnames(M1) <- c("Name", "Height", "Force")
M1
```


##

| [Name]{.bold-hilit} | [Height]{.bold-hilit} | [Force]{.bold-hilit} |
|------|------------|:------:|
| Leia | 1.50 | TRUE |
| Luke | 1.70 | TRUE |
| Han  | 1.80 | FALSE |

Write code to create a 3x3 matrix for the above data.

. . .

```{r}
#| output-location: fragment
Name <- c("Leia", "Luke", "Han")
Height <- c(1.50, 1.70, 1.80)
Force <- c(TRUE, TRUE, FALSE)

M2 <- cbind(Name, Height, Force) # column-bind
M2
```


##

| [Name]{.bold-hilit} | [Height]{.bold-hilit} | [Force]{.bold-hilit} |
|------|------------|:------:|
| Leia | 1.50 | TRUE |
| Luke | 1.70 | TRUE |
| Han  | 1.80 | FALSE |

Write code to create a matrix for the above data.

. . .

```{r}
#| output-location: fragment
leia <- c("Leia", 1.50, TRUE)
luke <- c("Luke", 1.70, TRUE)
han <- c("Leia", 1.80, FALSE)

M3 <- rbind(leia, luke, han) # row-bind
colnames(M3) <- c("Name", "Height", "Force")
M3
```


##

::::: columns
::: {.column .fragment width="45%"}
### Vectors

- Central data structure in R
  + Vectorization
  + Vector Recycling
- Ordered set of elements
  + Subsetting with `[]`
- Atomic: elements of the same type
  + Type coercion
:::

::: {.column width="10%"}
:::

::: {.column .fragment width="45%"}
### Matrices

- A vector with dimension info
  + Vectorization
  + Vector Recycling
- Ordered set of elements
  + Subsetting with `[vec_ind]` or `[row,col]`
- Also Atomic
:::
:::::


## Relevant Functions

::: {.nonincremental}
- `matrix()`
- `dim()`
- `nrow()`
- `ncol()`
- `rownames()`
- `colnames()`
- `cbind()`
- `rbind()`
:::
