---
title: "Working with Vectors"
format: stat133slides-revealjs
chalkboard: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, error = TRUE)
```

# Last time ...

## Vectors

- Central data structure in R

- Ordered set of elements

- **Atomic**: elements of the same type: `typeof()`

- Have `length()`

- Elements can be named: `names()`


## Atomic\*

Special values in an atomic vector.

-   `NA`: Not Available / Missing

-   `NULL`: Does not exist (nothing)

-   `NaN`: Not a Number (e.g. dividing by zero)

-   `Inf`: Infinity


## Functions to create vectors

- `c()`
- `vector(mode = , length = )`
    + `logical()`, `integer()`, `double()`, `character()`
- `seq(from = , to = , by = )`
- `rep(x, each = , times = , length.out = )`
- colon operator: `1:10`


##

Fill in the blanks to get the following sequences: 

```{r}
#| echo: false
countdown::countdown(1.5, bottom = 0)
```

```{r}
#| eval: false
seq(from = __, to = __, by = __)
```

```{r}
#| echo: false
seq(from = 3, to = 15, by = 3)
```

```{r}
#| code-fold: true
#| code-summary: "answer"
#| eval: false
seq(from = 3, to = 15, by = 3)
```

\

```{r}
#| eval: false
seq(from = __, to = __, by = __)
```

```{r}
#| echo: false
seq(from = 10, to = 0, by = -2)
```

```{r}
#| code-fold: true
#| code-summary: "answer"
#| eval: false
seq(from = 10, to = 0, by = -2)
```

\

```{r}
#| eval: false
seq(from = __, to = __, by = __)
```

```{r}
#| echo: false
seq(from = 0, to = -10, by = -2)
```

```{r}
#| code-fold: true
#| code-summary: "answer"
#| eval: false
seq(from = 0, to = -10, by = -2)
```


##

Fill in the blanks to get the following repetitions:

```{r}
#| echo: false
countdown::countdown(1, bottom = 0)
```

```{r}
#| eval: false
y <- c(0, 1, 2)

rep(y, times = __)
```

```{r}
#| echo: false
y <- c(0, 1, 2)
rep(y, times = 3)
```

```{r}
#| code-fold: true
#| code-summary: "answer"
#| eval: false
rep(y, times = 3)
```

\

```{r}
#| eval: false
rep(y, each = __)
```

```{r}
#| echo: false
y <- c(0, 1, 2)
rep(y, each = 2)
```

```{r}
#| code-fold: true
#| code-summary: "answer"
#| eval: false
rep(y, each = 2)
```

\

```{r}
#| eval: false
rep(y, times = __)
```

```{r}
#| echo: false
y <- c(0, 1, 2)
rep(y, times = 1:3)
```

```{r}
#| code-fold: true
#| code-summary: "answer"
#| eval: false
rep(y, times = 1:3)
```


# Behavior of Vectors

## Question

Turn to neighbor and speculate: what will each of the following lines of code return?

```{r}
#| eval: false
c(1, 2, 3) + c(2, 4, 8)

c(1, 2, 3) + c(2, 4)

c(1, "dog", TRUE)
```

```{r}
#| echo: false
countdown::countdown(2.5, bottom = 0)
```


## Vectorization

. . .

[Vectorized]{.bold-hilit}: Operations and functions that can run on an entire vector at once (i.e. element-wise computations)

. . .

```{r}
#| output-location: fragment
dbl_vec <- c(1, 2.3, 4)

log(dbl_vec) # vectorized
```

\

. . .

```{r}
#| output-location: fragment
# not vectorized
sum(dbl_vec) # vector-as-argument
```


## Vector Recycling

. . .

[Vector Recycling]{.bold-hilit}: If a function requires a longer vector than provided, it will fill the vector with the existing elements, in order.

. . .

```{r}
#| output-location: fragment
c(2, 6, 1)^2
```


## Coercion

. . .

[Implicit Coercion]{.bold-hilit}: Automatic change of data types to ensure atomic vectors. 

. . .

```{r}
#| output-location: fragment
c(1, "dog", TRUE)
```

. . .

\

Changes follow a hierarchy.

logical \< integer \< double \< character


## Coercion

[Explicit Coercion]{.bold-hilit}: R provides functions to explicitly coerce from one type to another.

-   `as.logical()`

-   `as.integer()`

-   `as.double()`

-   `as.character()`

. . .

Depending on what data-type you want to coerce to, these functions may or may not work.

. . .

```{r}
as.double(c(TRUE, FALSE, FALSE, FALSE))
```


# Vector Subsetting

## Square Bracket Syntax

## Subsetting by Index

*aka* numeric subsetting

```{r}
#| output-location: fragment
char_vec <- c("bear", "owl", "squirrel")
char_vec
```

. . .

```{r}
#| output-location: fragment
char_vec[2]
```

. . .

```{r}
#| output-location: fragment
char_vec[2:3] 
```

. . .

```{r}
#| output-location: fragment
char_vec[-2] 
```

. . .

\

[Recall that R starts indexing at 1!]{.mdlit}


## Subsetting by Name

*aka* character subsetting

```{r}
#| output-location: fragment
char_vec2 <- c("oski" = "bear", "fiat" = "owl", "lux" = "squirrel")
char_vec2
```

. . .

```{r}
char_vec2["oski"]
```

. . .

```{r}
char_vec2[c("lux", "fiat")]
```

## Subsetting by Logicals

*aka* logical subsetting

```{r}
char_vec2
```

. . .

\

```{r}
#| output-location: fragment
char_vec2[c(TRUE, FALSE, TRUE)]
```

. . .

Note: the logical vector should be of the same length.

```{r}
#| output-location: fragment
char_vec2[TRUE]
```


## Question

Write down three methods to generate each vector from the vector `z`, one for each subsetting method.

```{r}
z <- c(latte = 2, boba = 4, matcha = 6)
```

. . .

Vector 1:

```{r}
#| echo: false
z[2:1]
```

. . .

Vector 2:

```{r}
#| echo: false
z[c(3, 3)]
```

```{r}
#| echo: false
countdown::countdown(2.5, bottom = 0)
```

## Change in place syntax

You can assign into a subsetted vector to change its contents in place.

```{r}
#| output-location: fragment
z <- c(latte = 2, boba = 4, matcha = 6)
z[c(TRUE, FALSE, TRUE)] <- 12
z
```

. . .

```{r}
#| output-location: fragment
names(z)
```

. . .

```{r}
#| output-location: fragment
names(z) <- c("A", "B", "C")
z
```

