---
title: "Atomic Vectors"
subtitle: "R's building blocks"
format: stat133slides-revealjs
revealjs-plugins:
  - drop
chalkboard: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, error = TRUE)
```


## Announcements

- Office Hours / Group Tutoring

- DSP accommodations ✉️

- Quarto Publication 1 (Thu 1/29 in lab)

- Problem Set 1 (available Thu 1/29, due Wed 2/4)


# Vectors and Data Types

## {.nostretch}

![](images/leia-info.svg){width="83%" fig-align="center"}


## Leia's data objects {auto-animate=true}

::: {.columns}
::: {.column width="40%"}
![](images/leia-info2.png){fig-align="center" width="45%"}
:::

::: {.column .fragment width="50%"}
\

```{r}
name <- "Leia"
```

:::
:::


## Leia's data objects {auto-animate=true}

::: {.columns}
::: {.column width="40%"}
![](images/leia-info2.png){fig-align="center" width="45%"}
:::

::: {.column width="50%"}
\

```{r}
name <- "Leia"

gender <- "female"
```
:::
:::


## Leia's data objects {auto-animate=true}

::: {.columns}
::: {.column width="40%"}
![](images/leia-info2.png){fig-align="center" width="45%"}
:::

::: {.column width="50%"}
\

```{r}
name <- "Leia"

gender <- "female"

height <- 1.50
```
:::
:::


## Leia's data objects {auto-animate=true}

::: {.columns}
::: {.column width="40%"}
![](images/leia-info2.png){fig-align="center" width="45%"}
:::

::: {.column width="50%"}
\

```{r}
name <- "Leia"

gender <- "female"

height <- 1.50

force <- TRUE
```
:::
:::


## Data Types 

::: {.columns}
::: {.column width="50%"}
```{r}
# character (chr)
name <- "Leia"

# character (chr)
gender <- "female"

# logical (lgl)
force <- TRUE
```
:::

::: {.column .fragment width="50%"}
```{r}
# double (dbl)
height <- 1.50

# double (dbl)
height_cm <- 150

# integer (int)
height_cm2 <- 150L
```
:::
:::

\

. . .

BTW: All these objects are [vectors]{.bold-hilit}.

# More Data

## {.nostretch}

![](images/leia-luke-han-info.svg){width="84%" fig-align="center"}


## Vectors {auto-animate=true}

To create "larger" vectors we use the [combine]{.hilit} function `c()`

. . .

```{r}
#| output-location: fragment
name <- c("Leia", "Luke", "Han")
name
```

. . .

```{r}
#| output-location: fragment
gender <- c("female", "male", "male")
gender
```

. . .
```{r}
#| output-location: fragment
height <- c(1.50, 1.70, 1.80)
height
```

. . .
```{r}
#| output-location: fragment
force <- c(TRUE, TRUE, FALSE)
force
```


# Properties of Vectors

## Vectors

- Central---and most basic---data structure in R

- Ordered set of elements (i.e. contiguous cells)

- Can be of any length (including zero)

- [Atomic:]{.mdlit} elements of the same type

- Elements can have names


##

```{r}
#| output-location: fragment
name <- c("Leia", "Luke", "Han")
name
```

. . .

```{r}
#| output-location: fragment
length(name)
```

. . .

```{r}
#| output-location: fragment
height <- c(1.50, 1.70, 1.80)
height
```

. . .

```{r}
#| output-location: fragment
names(height) <- name
height
```

. . .

```{r}
#| output-location: fragment
weight_kg <- c("Leia" = 55, "Luke" = 75, "Han" = 85)
weight_kg
```


## Atomic Vectors

- Vectors are [atomic]{.hilit} structures

- The values in a vector must be [ALL]{.mdlit} of the same type!

- Either all logicals, or integers, or doubles, or characters

- You CANNOT have a vector of different data types


## Atomic*

Special values in an atomic vector:

- `NA`: Not Available / Missing

- `NULL`: Does not exist (nothing)

- `NaN`: Not a Number (e.g. dividing by zero)

- `Inf`: Infinity


## A comment about comments

[Comment character]{.bold-hilit}: special character to skip evaluation of remaining characters on a line. R (and Python) use `#`.

```{r}
#| output-location: fragment
# create vector
c("A", "C", "D") # vector created!
```

. . .

vs.

```{r}
#| output-location: fragment
create vector
c("A", "C", "D") vector created!
```


## R jargon: Types and Modes

- You'll often see/hear useRs talking about ["modes"]{.mdlit} instead of ["types"]{.hilit}.

- The function `typeof()` returns the [type of data]{.bold-hilit}: this is how the values are stored internally in R.

. . .

```{r}
#| output-location: fragment
typeof(name)
```

- In S terminology[^1], instead of talking about types we talk about [modes]{.mdlit}.

- The function `mode()` returns the "mode" of an R object.

. . .

```{r}
#| output-location: fragment
mode(name)
```

[^1]: S is the language on which R is based on.


## Types and Modes {.nostretch}

![](images/obj-vector-atomic-modes.png){width="70%" fig-align="center"}

- 4 main [types]{.hilit}: logical, integer, double, character
- 3 main [modes]{.mdlit}: logical, numeric, character


# Your Turn

##

| [Name]{.bold-hilit} | [House]{.bold-hilit} | [Spells]{.bold-hilit} |
|-----------|------------|:------:|
| Harry     | Gryffindor | 60 |
| Bellatrix | Slytherin  | 75 |
| Hermione  | Gryffindor | 70 |

\

. . .

```{r}
#| echo: false
countdown::countdown(1, bottom = 0)
```

Which command creates a valid vector `Name`?

::: {.nonincremental}
a) `Name <- (Harry, Bellatrix, Hermione)`
b) `Name <- c(Harry, Bellatrix, Hermione)`
c) `Name -> c("Harry", "Bellatrix", "Hermione")`
d) `Name <- c("Harry", "Bellatrix", "Hermione")`
:::


##

| [Name]{.bold-hilit} | [House]{.bold-hilit} | [Spells]{.bold-hilit} |
|-----------|------------|:------:|
| Harry     | Gryffindor | 60 |
| Bellatrix | Slytherin  | 75 |
| Hermione  | Gryffindor | 70 |

\

. . .

```{r}
#| echo: false
countdown::countdown(1.5, bottom = 0)
```

What is the [data type]{.bold-hilit} of the following vectors?

::: {.nonincremental}
a) `spells1 <- c(60, 75, 70)`
b) `spells2 <- c(60.0, 75.0, 70.0)`
c) `spells3 <- c(60L, 75L, 70L)`
d) `spells4 <- c("60", "75", "70")`
:::


##

```{r}
#| echo: false
countdown::countdown(1.5, bottom = 0)
```

Consider the following vectors:

::: {.nonincremental}
- `HH <- c("Harry", "Hermione")` 
- `Spells <- c(60, 75, 70)` 
:::

\

. . .

What is the [length]{.bold-hilit} of the following vectors?

::: {.nonincremental}
1) `v1 <- c(HH, "Ron")`
2) `v2 <- c(HH, c("Ron", "Luna"))`
3) `v3 <- c(Spells, Spells)`
4) `v4 <- c(Spells, NULL)`
:::


# Creating Vectors

## Functions to create vectors

R has a large repertoire of functions to create a variety of vectors.

We've already seen the combine function `c()`.

\

. . .

Functions to initialize "dummy" vectors:

- `logical(length = )`
- `integer(length = )`
- `double(length = )`
- `character(length = )`
- `vector(mode = , length = )`


## Functions to initialize "dummy" vectors

```{r}
#| output-location: fragment
logi <- logical(length = 2)
logi
```

. . .

```{r}
#| output-location: fragment
int <- integer(length = 3)
int
```

. . .

```{r}
#| output-location: fragment
dbl <- double(length = 4)
dbl
```

. . .

```{r}
#| output-location: fragment
char <- character(length = 5)
char
```

. . .

We typically create these vectors to have an output object whose elements will be populated or updated in later computations.


## Functions to create vectors: `vector()`

```{r}
logi <- vector(mode = "logical", length = 2)
logi
```

```{r}
int <- vector(mode = "integer", length = 3)
int
```

```{r}
dbl <- vector(mode = "double", length = 4)
dbl
```

```{r}
char <- vector(mode = "character", length = 5)
char
```


## Numeric Sequences with `seq()`

`seq()` allows you create numeric sequences of different kinds, for example:

. . .

```{r}
#| output-location: fragment
seq(from = 1, to = 5, by = 1)
```

. . .

```{r}
#| output-location: fragment
seq(from = 1, to = 10, by = 2)
```

. . .

```{r}
#| output-location: fragment
seq(from = 10, to = 1, by = -2)
```

. . .

```{r}
#| output-location: fragment
seq(from = 1, by = 2, length.out = 6)
```


## Numeric Sequences with `:`

The colon operator `:` also lets you create simple sequences

. . .

```{r}
#| output-location: fragment
1:5
```

. . .

```{r}
#| output-location: fragment
1:10
```

. . .

```{r}
#| output-location: fragment
10:1
```

. . .

```{r}
#| output-location: fragment
-3:3
```

. . .

```{r}
#| output-location: fragment
-3.5:3.5
```

. . .

The output sequence is produced in 1-unit steps.


## Replicates with `rep()`

`rep()` replicates the values of the input vector in a handful of different ways:

. . .

```{r}
#| output-location: fragment
rep(1, times = 3)
```

. . .

```{r}
#| output-location: fragment
rep(1:3, times = 2)
```

. . .

```{r}
#| output-location: fragment
rep(1:3, each = 2)
```

. . .

```{r}
#| output-location: fragment
rep(1:3, each = 2, times = 2)
```

. . .

```{r}
#| output-location: fragment
rep(1:3, each = 2, times = 2, length.out = 10)
```

